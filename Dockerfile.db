# Dockerfile for GTFS PostgreSQL Database with PostGIS
# Production-ready with dump restore from GitHub private repository
# Railway-compatible: Uses runtime download instead of build-time

FROM postgis/postgis:17-3.6-alpine

# Install required tools
RUN apk add --no-cache \
    postgresql-client \
    python3 \
    curl \
    bash

# Set environment variables with defaults (overridable via docker-compose)
ENV POSTGRES_PASSWORD=postgres \
    POSTGRES_USER=postgres \
    POSTGRES_DB=postgres \
    PGDATA=/var/lib/postgresql/data

# Ensure postgres user ownership and proper permissions for Railway volumes
RUN mkdir -p /var/lib/postgresql/data && \
    chown -R postgres:postgres /var/lib/postgresql && \
    chmod -R 700 /var/lib/postgresql/data

# Create initialization directory with proper ownership
RUN mkdir -p /docker-entrypoint-initdb.d && \
    chown postgres:postgres /docker-entrypoint-initdb.d

# Create PostGIS initialization script
RUN cat > /docker-entrypoint-initdb.d/00-enable-postgis.sh <<'SCRIPT_EOF'
#!/bin/sh
set -e
echo "===== $(date): Enabling PostGIS extension ====="
psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
  CREATE EXTENSION IF NOT EXISTS postgis;
  CREATE EXTENSION IF NOT EXISTS postgis_topology;
  SELECT PostGIS_version();
EOSQL
echo "===== $(date): PostGIS extension enabled ====="
SCRIPT_EOF

# Create optimized restore script with parallel processing
RUN cat > /docker-entrypoint-initdb.d/99-restore-dump.sh <<'SCRIPT_EOF'
#!/bin/sh
set -e
echo "===== $(date): Checking dump file ====="
DUMP_FILE="/docker-entrypoint-initdb.d/backup.dump"

if [ -f "$DUMP_FILE" ] && [ -s "$DUMP_FILE" ]; then
  SIZE=$(stat -c%s "$DUMP_FILE" 2>/dev/null || stat -f%z "$DUMP_FILE" 2>/dev/null)
  echo "Dump size: $(du -h $DUMP_FILE | cut -f1) ($SIZE bytes)"

  if [ "$SIZE" -lt 100000 ]; then
    echo "ERROR: Dump file is too small, likely an error page"
    echo "Skipping restore. Database will start empty."
    exit 0
  fi

  echo "Start restore: $(date)"
  JOBS=$(nproc 2>/dev/null || echo "2")
  echo "Using $JOBS parallel jobs for restore"

  pg_restore -U "$POSTGRES_USER" -d "$POSTGRES_DB" -v --no-owner --no-acl --jobs=$JOBS "$DUMP_FILE" 2>&1 | head -100 || echo "Restore completed with warnings"

  echo "===== $(date): Restore completed ====="

  # Clean up dump file to save space if requested
  if [ "$CLEANUP_DUMP" = "true" ]; then
    echo "Removing dump file to save space..."
    rm -f "$DUMP_FILE"
  else
    echo "Dump file retained (set CLEANUP_DUMP=true to remove)"
  fi
else
  echo "No valid dump file found. Database will start empty."
fi
SCRIPT_EOF

# Set proper ownership and permissions for all initialization scripts
RUN chmod +x /docker-entrypoint-initdb.d/00-enable-postgis.sh && \
    chmod +x /docker-entrypoint-initdb.d/99-restore-dump.sh && \
    chown postgres:postgres /docker-entrypoint-initdb.d/00-enable-postgis.sh && \
    chown postgres:postgres /docker-entrypoint-initdb.d/99-restore-dump.sh

# Copy custom entrypoint for GitHub download
COPY db_entrypoint.sh /usr/local/bin/db_entrypoint.sh
RUN chmod +x /usr/local/bin/db_entrypoint.sh

# Health check
HEALTHCHECK --interval=10s --timeout=5s --retries=5 \
  CMD pg_isready -U $POSTGRES_USER -d $POSTGRES_DB || exit 1

# Expose PostgreSQL port
EXPOSE 5432

# NOTE: VOLUME keyword is NOT used (Railway requirement)
# Configure volume via Railway Dashboard: /var/lib/postgresql/data (10GB+)

# NOTE: Do NOT set USER directive here
# The original docker-entrypoint.sh handles user switching from root to postgres

# Use custom entrypoint that downloads dump before starting PostgreSQL
ENTRYPOINT ["/usr/local/bin/db_entrypoint.sh"]

# Default command for PostgreSQL
CMD ["postgres"]
